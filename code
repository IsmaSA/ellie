for(i in 1:nrow(df)){
    df1 <- df[i, ]
}

###########
setwd("C:/Users/User/OneDrive - Queen's University Belfast/PhD - the general idea of the impacts of instream barriers in NI/AMBER Data/ROI")
atlas=read.csv("atlas.csv")
head(df)
install.packages("maps")
install.packages("rworldmap")
install.packages("rworldxtra")
library(maps)
library(rworldmap)
library(rworldxtra)

newmap <- getMap(resolution="high")
par(mar=c(0.5,0.5,0.5,0.5))
plot(newmap, col="tan1", border="black",bg="lightblue", 
     xlim=c(0, 40), ylim=c(30,72))

setwd("C:/Users/isma-/OneDrive/Escritorio/Crustaceans0/crustaceans/qgis")
riversData <- st_read("Europe_Hydrography.shp")
plot(riversData, col= "steelblue2", add=T)

unique(df$type)
df1 = df%>% filter(type=="dam") %>% filter(Country=="UNITED KINGDOM")
unique(df$Country)
names(df)
points(atlas1$Longitude_WGS84 , atlas1$Latitude_WGS84, 
       col="black", pch=23, cex=0.8, bg="red2")

library(remotes)
install.packages("sf")
library(sf)
df1 = df%>% filter(!country == "spain")
df1 = df1%>% filter(!country == "norway")

df2 <- st_as_sf(df1,coords = c("Longitude_X", "Latitude_Y"), crs = 4326)
CRS(df2)

df2 <- st_transform(df2, st_crs(riversData))
df3 <- st_join(df2, riversData, join = st_intersects)

atlas2 <- st_as_sf(atlas1,coords = c("Longitude_WGS84", "Latitude_WGS84"), crs = 4326)
atlas2 <- st_transform(atlas2, st_crs(riversData))
atlas3 <- st_join(atlas2, riversData, join = st_intersects)

rivers=unique(df3$geometry)
atlas3 = atlas3%>% filter(geometry %in% rivers)


######
dfgermany <- df%>% filter(country == "germany")
atlasgermany <- atlas%>% filter(Country =="germany")

dfgermany <- st_as_sf(dfgermany,coords = c("Longitude_X", "Latitude_Y"), crs = 4326)

dfgermany <- st_transform(dfgermany, st_crs(riversData))
dfgermany2 <- st_join(dfgermany, riversData, join = st_intersects)

dfgermany2 <- dfgermany2[!is.na(dfgermany2$geometry), ]

atlasgermany <- st_as_sf(atlasgermany,coords = c("Longitude_WGS84", "Latitude_WGS84"), crs = 4326)

atlasgermany <- st_transform(atlasgermany, st_crs(riversData))
atlasgermany2 <- st_join(atlasgermany, riversData, join = st_intersects)

atlasgermany2 <- atlasgermany2[!is.na(atlasgermany2$geometry), ]



names(atlasgermany2)
names(dfgermany2)

dfgermany3 = dfgermany2[, 10] 
dfgermany3$ID = "TimeSeries"

atlasgermany3 = atlasgermany2[, 13]
atlasgermany3$ID = "Atlas"

Data = rbind(atlasgermany3, dfgermany3)



for(e in nrow(dfgermany2)) { 
dfgermany3 = dfgermany2[dfgermany2$geometry == e,]  
  }

for(i in 1:nrow(dfgermany2)){
  dfgermany4 <- dfgermany2[i, ]
  dfgermany4_sf <- st_as_sf(dfgermany4, coords = c("geometry"))
  riversData_sf <- st_as_sf(riversData, coords = c("geometry"))
  buffered_points <- st_buffer(dfgermany4_sf, dist = 1000000) 
  intersection_result <- st_intersection(buffered_points, riversData_sf)
}


str(dfgermany4)
str(riversData)


#######
df=read_excel("Global_dataset.xlsx", sheet = "Sheet1")
install.packages("readxl")
library("readxl")
head(df)
setdiff(df$country, atlas$Country)
unique(df$country)
unique(atlas$Country)
atlas$Country=tolower(atlas$Country)
df$country=tolower(df$country)

df$country[df$country=="uk"]="united kingdom"
df$country[df$country=="czechrep"]="czech republic"

atlas1 = atlas%>%filter(Country %in% unique(df$country))


##### Ismael: 
  
df <- read_xlsx("Global_dataset.xlsx", sheet = "Sheet1")
head(df)
df <- df[,c(1,8,9)]
df <- df[!duplicated(df$site_id), ]
df<- df %>% drop_na()

atlas <- read.csv("atlas.csv")  
head(atlas)  
names(atlas)
atlas <- atlas[,c(5,6,13)]
atlas$ID <- 1:nrow(atlas)


riversData <- sf::st_read("HydroRIVERS_v10_eu.shp")
crs(riversData)
  
## Now combine df with riverData:
coordinates(df) <- ~Longitude_X+Latitude_Y
df_sf <- st_as_sf(df, coords = c("Longitude_X", "Latitude_Y"), crs = st_crs(riversData))
df_sf <- st_set_crs(df_sf, 4326) 

df_sf_projected <- st_transform(df_sf, crs = 4326)

# Apply a buffer in meters
df_sf_buffered <- st_buffer(df_sf_projected, dist = 1000)
riversData_projected <- st_transform(riversData, crs = st_crs(df_sf_projected))

# Now perform the spatial join with the buffered points
#intersections <- st_join(df_sf_projected, riversData_projected, join = st_intersects)
#intersections <- st_join(df_sf_projected, riversData_projected)

nearest_river_indices <- st_nearest_feature(df_sf_buffered, riversData_projected)
nearest_rivers <- riversData_projected[nearest_river_indices, ]
df_sf$ID_name <- nearest_rivers$HYRIV_ID
df_sf$geometry_river <- nearest_rivers$geometry

# River from where we have data:
river2<- riversData %>% filter(HYRIV_ID %in% unique(df_sf$ID_name))


################  Now the same but for atlas
coordinates(atlas) <- ~Longitude_WGS84 + Latitude_WGS84
atlas_sf <- st_as_sf(atlas, coords = c("Longitude_WGS84", "Latitude_WGS84"), crs = st_crs(river2))
atlas_sf <- st_set_crs(atlas_sf, 4326) 

# Apply a buffer in meters
atlas_sf_buffered <- st_buffer(atlas_sf, dist = 1000)
atlas_sf_buffered <- st_transform(atlas_sf_buffered, st_crs(river2))



# Visualization to see if works (or not)
df_sf$ID_name <- as.numeric(df_sf$ID_name)
riversData$HYRIV_ID <- as.character(riversData$HYRIV_ID)



  
ggplot() +
  geom_sf(data = river2, color = 'blue', size = 1) + 
  geom_sf(data = df_sf, color = 'red', size = 0.2) + theme_bw()
  

################## I want to try another approach...    ##########
   
str(df)
str(atlas)

df_sf <- st_as_sf(df, coords = c("Longitude_X", "Latitude_Y"), crs = 4326)
df_sf_buffered <- st_buffer(df_sf, dist = 50000) #50km

plot(df_sf_buffered)  # see the buffers 

atlas <- st_transform(atlas, st_crs(df_sf_buffered))

joined <- st_join(df_sf_buffered, atlas, join = st_intersects)

dam_counts <- joined %>%
  group_by(site_id) %>%
  summarise(dam_count = sum(!is.na(GRAND_ID)), .groups = 'drop')


## try witht he other damns layer

str(df)
atlas = read.csv("atlas.csv")
str(atlas)

atlas_sf <- st_as_sf(atlas, coords = c("Longitude_WGS84", "Latitude_WGS84"), crs = 4326)
df_sf_buffered 

joined <- st_join(df_sf_buffered, atlas_sf, join = st_intersects)

# Count the number of dams 
library(dplyr)
dam_counts <- joined %>%
  group_by(site_id, type) %>%
  summarise(dam_count = n_distinct(GUID), .groups = 'drop')  

##########community dynamics of time series#####
dfAbundance <- df %>% group_by(site_id, year)%>% summarise(Totalabundance = sum(abundance))
dfRichness <- df %>% group_by(site_id, year)%>% summarise(richness = n())
#dfRichness <- df %>% group_by(site_id, year)%>% summarise(richness = n_distinct(taxon))
df1 <- df %>% group_by(site_id, year, taxon)%>% summarise(abundance = sum(abundance)) %>% pivot_wider(names_from = taxon, values_from = abundance, values_fill = 0)

#Shannon diversity 
library(vegan)
library(tidyr)
Shannon <- diversity(df1, index = "shannon")
Shannon1 <- as.data.frame(Shannon)
Shannon1$site_id <- df1$site_id
Shannon1$year <- df1$year

#Simpson diversity
Simpson <- diversity(df1, index = "simpson")
Simpson1 <- as.data.frame(Simpson)
Simpson1$site_id <- df1$site_id
Simpson1$year <- df1$year

#evenness
library("SciViews")
dfEvenness <- Shannon1$Shannon/log(dfRichness$richness)
dfEvenness <- as.data.frame(Evenness)
dfEvenness$site_id <- df1$site_id
dfEvenness$year <- df1$year

#Number of native and non-natives
NoNN <- df %>% group_by(site_id, year, Alien)%>% summarise(richness = n_distinct(taxon))

#Abundance of native and non-native
AlienAbundance <- df %>% group_by(site_id, year, Alien) %>% summarise(abundance = sum(abundance))

#Proportional abundances
#join df to abundance 
dfJoined <- left_join(dfAbundance, AlienAbundance, by = c("site_id", "year"))

dfJoined$proportion <- dfJoined$abundance/dfJoined$Totalabundance*100


###Combine predictors into one dataframe
#I'm not sure of any of this but it does work. I am still working on line 270 because when I use semi_join it looses proportion from dfJoined but with left_join it has duplicated columns
#I used cbind() for the abundance, evenness and diversity indices because they all have the same number of rows

library(tidyverse)
dfCombine1 <- dfAbundance %>%
  cbind(Evenness1, Shannon1, Simpson1) 

names(dfCombine1)
dfCombine1 <- dfCombine1[,-c(5, 6, 8, 9, 11, 12)]
colnames(dfCombine1)[1]<- "site_id"
colnames(dfCombine1)[2]<- "year"

dfCombine1 <- dfCombine1 %>%
  left_join(dfRichness, by = c("site_id", "year"))

dfCombine1 <- dfCombine1 %>% 
  left_join(dfJoined, by = c("site_id", "year"))

names(dfCombine1)
dfCombine1 <- dfCombine1[,-c(3)]
names(dfCombine1)
colnames(dfCombine1)[7]<- "Totalabundance"





###############################################################################
##### GLM #############################
continuous <- select_if(df, is.numeric)
summary(continuous)
#plot the distribution

hist(dfCombine1$richness)
sd(dfCombine1$richness)
mean(dfCombine1$richness)

str(dfCombine1)


library(MASS)
dfCombine2$country <- as.factor(dfCombine2$country)
GLM1 <- glmer.nb(richness ~ year + (1|country), data = dfCombine2)
summary(GLM1)

dfCombine2 <- dfCombine2 %>% drop_na()

options(scipen = 999)

barrier <- read_xlsx("Copy of dam.xlsx")
dfCombine2 <- dfCombine1 %>%
  left_join(barrier, by = "site_id")
dfCombine2 <- dfCombine2 %>% distinct(site_id, year, Evenness, Shannon, Simpson, richness, Totalabundance, Alien, abundance, proportion, type, dam_count, country)

names(dfCombine2)


dfCombine2 <- dfCombine2 %>%
  left_join(df[, c(1, 5)], by = "site_id")



#############################################  Note: Upload also the data :s in the "data" folder:  ############################################################
# Try making a gamms (i.e., not linear model)

library(mgcv)
# Note: type must be a factor (it is a categorical variable)
# Note "s()" is the smoother and "re" to select the random effect.
# Country must be a factor


gamm_isma <- gam(richness ~ type + s(dam_counts) + s(year) + s(country, bs="re"),
            data = dfCombine2, select =T,
            family = nb())

op <- par(mfrow=c(2,2), mar=c(4,4,1,1))
gam.check(gamm_isma)
par(op)
summary.gam(gamm_isma)
op <- par(mfrow=c(3,3), mar=c(4,4,1,1))
plot(gamm_isma, all.terms = TRUE, rug=TRUE, shade= TRUE, shade.col = "lightblue", seWithMean = TRUE, residuals=TRUE)



#####################Ellie gamms#####
#remove NA from time series with NA dam count & type 
dfCombine2 <- dfCombine2 %>% filter(!site_id %in% c("103000515", "111000058", "111000062", "119000001", "119000003", "119000004", "119000007", "119000009"))
str(dfCombine2)

dfCombine2$site_id <- as.character(dfCombine2$site_id)
anyNA(dfCombine2)

dfCombine2$richness <- as.numeric(dfCombine2$richness)
dfCombine2$type <- as.factor(dfCombine2$type)
dfCombine2$country <-as.factor(dfCombine2$country)


gamm_isma <- gam(richness ~ type + s(dam_count) + s(year) + s(country, bs="re"),
                 data = dfCombine2, select =T,
                 family = nb())

op <- par(mfrow=c(2,2), mar=c(4,4,1,1))
gam.check(gamm_isma)
par(op)
summary.gam(gamm_isma)
op <- par(mfrow=c(3,3), mar=c(4,4,1,1))
plot(gamm_isma, all.terms = TRUE, rug=TRUE, shade= TRUE, shade.col = "lightblue", seWithMean = TRUE, residuals=TRUE)

dfCombine2 <- dfCombine2[dfCombine2$year > 1999, ]

###########Combining dfCombine with full data (i.e., temp, strahler etc.) and changing dam count from 50 to km data
barrier <- read_xlsx("dam_counts_10km.xlsx")
barrier$site_id <- as.character(barrier$site_id)
dfCombine2 <- dfCombine2 %>%
  left_join(barrier, by = "site_id")

names(dfCombine2)
dfCombine2 <- dfCombine2[,-c(11, 12, 16)]
names(dfCombine2)
colnames(dfCombine2)[12]<- "type"
colnames(dfCombine2)[13]<- "dam_count"

fulldata <- read_xlsx("Full_data.xlsx")

fulldata$site_id <- as.character(fulldata$site_id)

dfCombine2 <- dfCombine2 %>%
  left_join(fulldata[, c(1, 22, 23, 24, 26, 29, 30, 31, 32)], by = "site_id")

names(dfCombine2)
names(fulldata)
str(fulldata)
str(dfCombine2)






##########################################################################################################################################
#####Tidied R code###############

setwd("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/ROI")

library(readxl)
library(tidyr)
library(dplyr)
library(sf)

df <- read_xlsx("Global_dataset.xlsx", sheet = "Sheet1")

##Community metrics
dfAbundance <- df %>% group_by(site_id, year)%>% summarise(Totalabundance = sum(abundance))
dfRichness <- df %>% group_by(site_id, year)%>% summarise(richness = n())
#dfRichness <- df %>% group_by(site_id, year)%>% summarise(richness = n_distinct(taxon))
df1 <- df %>% group_by(site_id, year, taxon)%>% summarise(abundance = sum(abundance)) %>% pivot_wider(names_from = taxon, values_from = abundance, values_fill = 0)

##Shannon diversity 
library(vegan)
library(tidyr)

Shannon <- diversity(df1, index = "shannon")
Shannon1 <- as.data.frame(Shannon)
Shannon1$site_id <- df1$site_id
Shannon1$year <- df1$year

##Simpson diversity
Simpson <- diversity(df1, index = "simpson")
Simpson1 <- as.data.frame(Simpson)
Simpson1$site_id <- df1$site_id
Simpson1$year <- df1$year

#evenness
library("SciViews")
Evenness <- Shannon1$Shannon/log(dfRichness$richness)
Evenness1 <- as.data.frame(Evenness)
Evenness1$site_id <- df1$site_id
Evenness1$year <- df1$year

#Number of native and non-natives
NoNN <- df %>% group_by(site_id, year, Alien)%>% summarise(richness = n_distinct(taxon))

#Abundance of native and non-native
AlienAbundance <- df %>% group_by(site_id, year, Alien) %>% summarise(abundance = sum(abundance))

#Proportional abundances
#join df to abundance 
dfJoined <- left_join(dfAbundance, AlienAbundance, by = c("site_id", "year"))

dfJoined$proportion <- dfJoined$abundance/dfJoined$Totalabundance*100




##Turnover#########################
tover <- df %>% group_by(site_id, year, taxon) %>% summarise(abundance = sum(abundance, na.rm = T))


library(codyn)
turnover(
  tover,
  time.var = "year",
  species.var = "taxon",
  abundance.var = "abundance",
  replicate.var = NA,
  metric = "total"
)


###
turnover_df <- data.frame(Site = character(),
                          Year = numeric(),
                          Turnover = numeric())

# Iterate over the two sites
for (site in unique(df$site_id)) {
  # Filter the data for the current site
  site_data <- tover %>% filter(site_id == site)
  
  # Group by year and calculate turnover
  site_turnover <- turnover(
    site_data,
    time.var = "year",
    species.var = "taxon",
    abundance.var = "abundance",
    metric="total"
  )
  
  # Combine the results into a data frame
  site_turnover_df <- data.frame(Site = site,
                                 Year = site_turnover$year,
                                 Turnover = site_turnover$total)
  
  # Add the results to the main data frame
  turnover_df <- rbind(turnover_df, site_turnover_df) 
  cat("done:", site)
}



####Combine coomunity dynamics into one df
dfCombine <- dfAbundance %>%
  cbind(Evenness1, Shannon1, Simpson1) 

names(dfCombine)
dfCombine <- dfCombine[,-c(5, 6, 8, 9, 11, 12)]
colnames(dfCombine)[1]<- "site_id"
colnames(dfCombine)[2]<- "year"

dfCombine <- dfCombine %>%
  left_join(dfRichness, by = c("site_id", "year"))

dfCombine <- dfCombine %>% 
  left_join(dfJoined, by = c("site_id", "year"))

names(dfCombine)
dfCombine <- dfCombine[,-c(3)]
names(dfCombine)
colnames(dfCombine)[7]<- "Totalabundance"


#add country, longitude and latitude to dfCombine
dfCombine <- dfCombine %>%
  left_join(df[, c(1, 2, 3, 5, 8, 9)], by = "site_id")

names(dfCombine)

dfCombine <- dfCombine[,-c(11)]
names(dfCombine)
colnames(dfCombine)[2]<- "year"

dfCombine <- dfCombine %>% distinct(site_id, year, Evenness, Shannon, Simpson, richness, Totalabundance, Alien, abundance, proportion, taxon, country, Longitude_X, Latitude_Y)

#remove no longer necessary df
rm(NoNN, Shannon, Shannon1, Evenness, Evenness1, Simpson1, Simpson, AlienAbundance, dfAbundance, dfRichness, df1, dfJoined)

gc()



####################
##Combine abiotic predictors into one dataframe
fulldata <- read_xlsx("Full_data.xlsx")
names(fulldata)

pdata <- fulldata[, c("site_id", "Temperature", "Precipitation", "distance to outlet", "distance to weir")]
names(pdata)
colnames(pdata)[4]<- "distance_to_outlet"
colnames(pdata)[5]<- "distance_to_weir"
pdata <- pdata %>% distinct(site_id, Temperature, Precipitation, distance_to_outlet, distance_to_weir)

#Combine with site_id, year, and country from dfCombine
names(dfCombine)

pdata <- pdata %>%
  left_join(dfCombine[, c(1, 2, 12)], by = "site_id")

names(pdata)


pdata <- pdata %>% distinct(site_id, Temperature, Precipitation, distance_to_outlet, distance_to_weir, year, country)

gc()


##add type and dam_count
barrier <- read_xlsx("dam_counts_10km.xlsx")
pdata <- pdata %>%
  left_join(barrier[, c(1, 2, 3)], by = "site_id")
names(pdata)

rm(barrier)

pdata <- pdata %>% distinct(site_id, Temperature, Precipitation, distance_to_outlet, distance_to_weir, year, country, type, dam_count)


gc()


#ggplot
names(dfCombine)
library(ggplot2)
dfCombine$site_id <- as.factor(dfCombine$site_id)
dfCombine$year <- as.numeric(dfCombine$year)

ggplot(data=dfCombine, aes(x= year, y= site_id)) +
  geom_line(aes(x=year)) +
  labs(title="Time Series per country pre year", x="Time", y="Time Series") +
  scale_color_manual(values = c('#0072B2','#E69F00','#D55E00','#009E73','#56B4E9'))

ggplot(data = dfCombine[!dfCombine$country %in% c("Germany", "Bulgaria"), ], aes(x = year, y = site_id, color = country)) +
  geom_line() +
  labs(title = "Time Series per country per year",
       x = "Time",
       y = "Site ID") + geom_vline(xintercept = 1995, size = 1.5, color = "red")+ geom_vline(xintercept = 2018, size = 1.5, color = "red")






#####Narrow data
#remove germany and bulgaria
dfCombine <- dfCombine %>% filter(!country %in% c ("Germany", "Bulgaria"))
pdata <- pdata %>% filter(!country %in% c ("Germany", "Bulgaria"))


#Narrow dates (1995 - 2018)
dfCombine <- dfCombine[dfCombine$year >= 1995 & dfCombine$year <= 2018, ]
pdata <- pdata[pdata$year >= 1995 & pdata$year <= 2018, ]


#get rid of NAs
anyNA(dfCombine)
anyNA(pdata)

options(scipen = 999)

#Remove TS with only one dam count because this is the time series and then this will remove all the ones without a barrier
pdata <- pdata %>% filter(!dam_count == "1")

#remove duplicated TS by site_id and type 
pdata <- pdata[!duplicated(pdata[, c("site_id", "type")]), ]

#now duplicates and NAs in dfCombine
anyNA(dfCombine)
##Could possibly remove the year and taxon variables in dfCombine but keep alien (Y/N)
#The row abundance has the number of Native and non-native when you keep alien
#remove duplicate rows in dfCombine by the site_id and alien
dfCombine <- dfCombine[!duplicated(dfCombine[, c("site_id", "Alien")]), ]


#Combine dfCombine and pdata
dfCombine2 <- dfCombine %>%
  left_join(pdata, by = c("site_id", "year", "country"))

names(dfCombine2)




###################################################################
###GAMMs
# Note: type must be a factor (it is a categorical variable)
# Note "s()" is the smoother and "re" to select the random effect.
# Country must be a factor
####rotate the data before the gamm = wide to long?
#Also which columns need to be numerical etc.
#remove NA from time series with NA dam count & type 
str(dfCombine)

dfCombine2$site_id <- as.character(dfCombine2$site_id)
dfCombine2$richness <- as.numeric(dfCombine2$richness)
dfCombine2$type <- as.factor(dfCombine2$type)
dfCombine2$country <-as.factor(dfCombine2$country)



#############Why not GLMM? can we try this again
#Also try maybe river nested in country

#####GAMMs
library(mgcv)

##Basic gam

b <- dfCombine2 %>% filter(dam_count <1000)

gamm <- gam(richness ~ type + s(dam_count) + s(country, bs="re"),
            data = b, select =T,
            family = nb())

op <- par(mfrow=c(2,2), mar=c(4,4,1,1))
gam.check(gamm)
par(op)
summary.gam(gamm)
op <- par(mfrow=c(3,3), mar=c(4,4,1,1))
plot(gamm, all.terms = TRUE, rug=TRUE, shade= TRUE, shade.col = "lightblue", seWithMean = TRUE, residuals=TRUE)


dev.off()


############################## Code to count the number of barriers

library(readxl)
library(tidyr)
library(sf)
library(dplyr)
df <- read_xlsx("Global_dataset (2).xlsx", sheet = "Sheet1")
head(df)
df <- df[,c(1,5,8,9)]
df <- df[!duplicated(df$site_id), ]
df<- df %>% drop_na()

str(df)
atlas = read.csv("atlas.csv")
str(atlas)

atlas_sf <- st_as_sf(atlas, coords = c("Longitude_WGS84", "Latitude_WGS84"), crs = 4326)
df_sf_buffered 


df_sf <- st_as_sf(df, coords = c("Longitude_X", "Latitude_Y"), crs = 4326)
df_sf_buffered <- st_buffer(df_sf, dist = 10000) #10km

joined <- st_join(df_sf_buffered, atlas_sf, join = st_intersects)

# Count the number of dams 
library(dplyr)
dam_counts <- joined %>%
  group_by(site_id, type) %>%
  summarise(dam_count = n_distinct(GUID), .groups = 'drop')




### Code to extract the buffer ID that intersect with the time series:

rivers<- sf::st_read("WholeRiv_Buffers.shp")

ts<- sf::st_read("dfSF.shp")
ts1 <- ts[!duplicated(ts$site_id), ] # 1814
nrow(ts1) # 1814

str(ts1)
str(rivers)


intersects <- st_intersects(ts1, rivers)

invalid_indices <- which(!st_is_valid(rivers))
if (length(invalid_indices) > 0) {
  invalid_reasons <- st_is_valid(rivers, reason = TRUE)[invalid_indices]
  print(data.frame(index = invalid_indices, reason = invalid_reasons))
} else {
  print("No invalid geometries found.")
}
rivers_clean <- rivers[-invalid_indices, ]
intersects <- st_intersects(ts1, rivers_clean)
nrow(intersects) # 1814


intersecting_ids <- data.frame()
for (i in seq_len(length(intersects))) {
  intersecting_rivers_indices <- intersects[[i]]
  
  if (length(intersecting_rivers_indices) > 0) {
    current_site_id <- ts1$site_id[i]
    river_ID <- rivers[intersecting_rivers_indices,]
    river_ID1<- river_ID$Buffer_ID
    
    intersecting_ids <- rbind(intersecting_ids, data.frame("site_id" =current_site_id,
                                                           "River_ID" = river_ID1 ))
          cat(":-D", "/n:")
  }
}


setdiff(unique(ts1$site_id), intersecting_ids$site_id)
write_xlsx(intersecting_ids, "intersecting_ids.xlsx")



####

atlas <- read.csv("atlas.csv")
str(atlas)
str(intersecting_ids)
str(rivers_clean)

atlas_sf <- st_as_sf(atlas, coords = c("Longitude_WGS84", "Latitude_WGS84"), crs = 4326)
rivers_clean <- st_transform(rivers_clean, st_crs(atlas_sf))

intersecting_buffers <- intersecting_ids %>%
  left_join(rivers_clean, by = c("River_ID" = "Buffer_ID"))


intersecting_buffers_sf <- intersecting_buffers %>%  st_as_sf()
nrow(intersecting_buffers_sf) # 1767


chunk_size <- 10
num_chunks <- ceiling(nrow(intersecting_buffers_sf) / chunk_size)

for (i in 1:num_chunks) {
  start_index <- (i - 1) * chunk_size + 1
  end_index <- min(i * chunk_size, nrow(intersecting_buffers_sf))
  
  #time_series = intersecting_buffers_sf$site_id[i]
  intersecting_barriers_chunk <- st_intersection(atlas_sf, intersecting_buffers_sf[start_index:end_index, ])
  #intersecting_barriers_chunk$site_id = time_series
  
  intersecting_barriers_chunk$geometry_wkt <- st_as_text(intersecting_barriers_chunk$geometry)
  csv_file_name <- paste0("intersecting_barriers_chunk_", i, ".csv")
  write.csv(intersecting_barriers_chunk[, -which(names(intersecting_barriers_chunk) == "geometry")], 
            csv_file_name, row.names = FALSE)
  cat("SIUH")
}




#############################################################
###Might be completely wrong

intersecting_buffers <- intersecting_ids %>%
  left_join(rivers_clean, by = c("River_ID" = "Buffer_ID"))

####
#Break down the number of rivers in intersecting barriers
###unique values in intersecting_buffers River_IDs
unique_values <- unique(intersecting_buffers$River_ID)

# To count the number of different unique values, you can use the length() function
num_unique_values <- length(unique_values)

# Print the unique values and the count
print(unique_values)
print(num_unique_values)

#325 unique values


#########

##River buffers with TS in them
# Extract unique values from the "River_ID" column in the first DataFrame
# Subset rows from rivers_clean based on the unique IDs
subset_rivers_clean <- rivers_clean[rivers_clean$Buffer_ID %in% unique_values, ]

# Check the dimensions of the subsetted DataFrame
dim(subset_rivers_clean)

# Alternatively, if you want to create a new DataFrame with only the subsetted rows:
rivers_with_TS <- rivers_clean[rivers_clean$Buffer_ID %in% unique_values, ]

#325 rivers_with_TS


########
atlas <- read.csv("atlas.csv")
str(atlas)
str(intersecting_ids)
str(rivers_clean)
str(rivers_with_TS)

atlas_sf <- st_as_sf(atlas, coords = c("Longitude_WGS84", "Latitude_WGS84"), crs = 4326)
rivers_clean <- st_transform(rivers_clean, st_crs(atlas_sf))
rivers_with_TS <- st_transform(rivers_with_TS, st_crs(atlas_sf))

#instead of using intersecting_buffers as the sf we can now use rivers with TS
nrow(rivers_with_TS) #325

rm(atlas, intersecting_buffers, intersecting_ids, intersects, river_ID, rivers, subset_rivers_clean, ts, current_site_id, i, intersecting_rivers_indices, invalid_indices, invalid_reasons, num_unique_values, river_ID1, unique_values)


names(atlas_sf)
atlas_sf <- atlas_sf[, -c(2, 3, 4, 5, 7, 8, 9, 10)]
atlas_sf <- atlas_sf[!duplicated(atlas_sf$GUID), ]

names(rivers_with_TS)
rivers_with_TS <- rivers_with_TS[, -c(2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)]
rivers_with_TS <- rivers_with_TS[!duplicated(rivers_with_TS$Buffer_ID), ]


#creating a 10km buffer around the river geometries
rivers_10km <- st_buffer(rivers_with_TS, dist = 10000) #10km

gc()

#filtered_atlas <- st_intersection(atlas_sf, rivers_10km)

filtered_atlas <- st_join(rivers_10km, atlas_sf, join = st_intersects)

#join to rivers with TS
TSrivers_with_barriers <- st_join(rivers_with_TS, filtered_atlas, join = st_intersects)


# Perform intersection
#intersection <- st_intersection(filtered_atlas, rivers_with_TS)
#intersecting_barriers <- st_intersection(atlas_sf, rivers_with_TS)


write.csv(filtered_atlas, "C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer//filtered_atlas.csv")

#tidy TSrivers_with_barriers
#remove all rows without barriers
TSrivers_with_barriers2 <- TSrivers_with_barriers[complete.cases(TSrivers_with_barriers$GUID), ]
#remove the duplicated columns
names(TSrivers_with_barriers2)
TSrivers_with_barriers2 <- TSrivers_with_barriers2[, -c(4, 5, 6)]
colnames(TSrivers_with_barriers2)[1] <- "HYRIV_ID"
colnames(TSrivers_with_barriers2)[2] <- "MAIN_RIV"
colnames(TSrivers_with_barriers2)[3] <- "Buffer_ID"
#remove all dulplicates
TSrivers_with_barriers2 <- TSrivers_with_barriers2[!duplicated(TSrivers_with_barriers2$GUID), ] ###### This almost halfed the number of observations so maybe double check - potentially there were barriers in more than one buffer?


write.csv(TSrivers_with_barriers2, "C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer//TSrivers_with_barriers2.csv")

write.csv(rivers_with_TS, "C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer//rivers_with_TS.csv")







####### LAST SHOT!
############ River Buffers ##############
river_buffers <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer//WholeRiv_Buffers.shp")
ts <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/ROI//dfSF.shp")

ts <- ts[!duplicated(ts$site_id), ]
nrow(ts)

str(ts)
str(river_buffers)

# Clean the file to remove those invalid figures:
invalid_indices <- which(!st_is_valid(river_buffers))
if (length(invalid_indices) > 0) {
  invalid_reasons <- st_is_valid(river_buffers, reason = TRUE)[invalid_indices]
  print(data.frame(index = invalid_indices, reason = invalid_reasons))
} else {
  print("No invalid geometries found.")
}

# Clean the file:
rivers_clean <- river_buffers[-invalid_indices, ]

# Now this is working:
intersects <- st_intersects(ts, rivers_clean)

nrow(intersects) # 1814

intersecting_ids <- data.frame()
for (i in seq_len(length(intersects))) {
  intersecting_rivers_indices <- intersects[[i]]
  
  if (length(intersecting_rivers_indices) > 0) {
    current_site_id <- ts$site_id[i]
    river_ID <- river_buffers[intersecting_rivers_indices,]
    river_ID1<- river_ID$Buffer_ID
    
    intersecting_ids <- rbind(intersecting_ids, data.frame("site_id" =current_site_id,
                                                           "River_ID" = river_ID1 ))
    cat(":-D", "/n:")
  }
}
#done

setdiff(unique(ts$site_id), intersecting_ids$site_id)
write_xlsx(intersecting_ids, "intersecting_ids.xlsx")

intersecting_ids <- read_xlsx("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/ROI//intersecting_ids.xlsx")


#unique TS site_ids that intersect with rivers
unique_values2 <- unique(intersecting_ids$site_id)
num_unique_values2 <- length(unique_values2)
print(unique_values2)
print(num_unique_values2)
#1746 unique values

#TS that fall in river buffers
TS_in_rivers <- ts[ts$site_id %in% unique_values2, ]

write_sf(TS_in_rivers, "C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer//TS_in_rivers.shp")


############# This is where I think something was going wrong ######################
###
#left join intersecting_ids and rivers to get all the information of the rivers - including their buffer IDs 
#then we will transfer it over to QGIS

intersecting_buffers <- intersecting_ids %>%
  left_join(rivers_clean, by = c("River_ID" = "Buffer_ID"))

#write intersecting_buffers as csv
write.csv(intersecting_buffers, "C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer//rivers_with_TS.csv")

write_sf(intersecting_buffers, "C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer//intersecting_buffers.shp")

#When we look then at the intersecting_buffers in QGIS it only has a few of them. Completely misses major parts of Europe

#########################################################



########### Fixing it #########################
###To fix the above I took the TS that are in rivers to QGIS
#####The TS_in_rivers was joined with the wholeriverbuffers in QGIS to find the rivers that have TS and their unique buffer IDs 
##this new shapefile will then be used to find the barriers that intersect that 

####The work that was done in QGIS,  could have potentially been done using the following code in R (but I have not tried it so cannot say it would work)####
#Break down the number of rivers in intersecting barriers
###unique values in intersecting_buffers River_IDs
unique_values <- unique(intersecting_buffers$River_ID)

# To count the number of different unique values, you can use the length() function
num_unique_values <- length(unique_values)

# Print the unique values and the count
print(unique_values)
print(num_unique_values)

#325 unique values

##River buffers with TS in them
# Extract unique values from the "River_ID" column in the first DataFrame
# Subset rows from rivers_clean based on the unique IDs
subset_rivers_clean <- rivers_clean[rivers_clean$Buffer_ID %in% unique_values, ]

# Check the dimensions of the subsetted DataFrame
dim(subset_rivers_clean)

# Alternatively, if you want to create a new DataFrame with only the subsetted rows:
rivers_with_TS <- rivers_clean[rivers_clean$Buffer_ID %in% unique_values, ]

#325 rivers_with_TS

write_sf_rivers_with_TS, "C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer//rivers_with_TS.shp")

##################################



######## Now finding the barriers in those rivers that we got from the QGIS work ###############
setwd("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/ROI")
atlas <- read.csv("atlas.csv")
str(atlas)

atlas_sf <- st_as_sf(atlas, coords = c("Longitude_WGS84", "Latitude_WGS84"), crs = 4326)

#This is the Shapefile from QGIS I will send this
RiverBuffers_withTS <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer//RiverBuffers_withTS.shp")


###Tidy up the data and workspace might be easier to work with
rm(atlas, intersecting_buffers, intersecting_ids, intersects, river_ID, rivers, subset_rivers_clean, current_site_id, i, intersecting_rivers_indices, invalid_indices, invalid_reasons, num_unique_values, river_ID1, unique_values)

names(atlas_sf)
atlas_sf <- atlas_sf[, -c(2, 3, 4, 5, 7, 8, 9, 10)]
atlas_sf <- atlas_sf[!duplicated(atlas_sf$GUID), ]

names(RiverBuffers_withTS)
RiverBuffers_withTS <- RiverBuffers_withTS[, -c(4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 19, 21, 22, 25, 26)]
RiverBuffers_withTS <- RiverBuffers_withTS[, -c(6, 7)]
RiverBuffers_withTS <- RiverBuffers_withTS[!duplicated(RiverBuffers_withTS$Buffer_ID), ]
RiverBuffers_withTS <- RiverBuffers_withTS[!duplicated(RiverBuffers_withTS$site_id), ]

####We'll split the buffers into chunks
chunk_size <- 10
start_chunk <- 1
num_chunks <- ceiling(nrow(RiverBuffers_withTS) / chunk_size) #I think 32-33 chunks

for (i in start_chunk:num_chunks) {
  start_index <- (i - 1) * chunk_size + 1
  end_index <- min(i * chunk_size, nrow(RiverBuffers_withTS))
  
  #time_series = intersecting_buffers_sf$site_id[i]
  intersecting_barriers_chunk <- st_intersection(atlas_sf, RiverBuffers_withTS[start_index:end_index, ])
  #intersecting_barriers_chunk$site_id = time_series
  
  intersecting_barriers_chunk$geometry_wkt <- st_as_text(intersecting_barriers_chunk$geometry)
  csv_file_name <- paste0("2bintersecting_barriers_chunk_", i, ".csv")
  write.csv(intersecting_barriers_chunk[, -which(names(intersecting_barriers_chunk) == "geometry")], 
            csv_file_name, row.names = FALSE)
  cat("SIUH")
}

#done


#the files created byt the chunks were mereged in excel
intersecting_barriers <- read_xlsx("2b_all_barriers.xlsx")
intersecting_barriers <- intersecting_barriers[!duplicated(intersecting_barriers$GUID), ] 

#remove empty rows
intersecting_barriers <- intersecting_barriers[complete.cases(intersecting_barriers$Buffer_ID), ]



#creating shapefile to see in maps
intersecting_barriers_sf <- st_as_sf(intersecting_barriers, wkt = "geometry_wkt", crs = 4326)
st_write(intersecting_barriers_sf, "C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer/Intersecting barrier chunks/CSVs//intersecting_barriers.shp")




#### Preparing the data for further work
unique(intersecting_barriers$type)
intersecting_barriers <- intersecting_barriers[intersecting_barriers$type != "other", ]

#remove Germany and Belgium from the TS and Barriers



#### Note: not all TS rivers have recorded barriers in them - I am pretty sure the river in Ireland with TS doesn't have any AMBER barriers but if all the above is okay it should'nt be hard to go remove the rivers and ts that have no barriers







# subset of the code for Spain:   Ismael

rivers <- st_read(setwd("C:/Users/Propietario/Desktop/Slovakia database/HydroRIVERS_v10_eu_shp"))

spain_bbox <- st_sfc(st_polygon(list(rbind(c(-9.392883, 35.946850), 
                                           c(-9.392883, 43.748337), 
                                           c(3.039484, 43.748337), 
                                           c(3.039484, 35.946850),
                                           c(-9.392883, 35.946850)))),
                                  crs = st_crs(rivers))

river_spain <- st_intersection(rivers, spain_bbox)
plot(st_geometry(river_spain)) # it words iberian peninsula

main_rivers <- river_spain %>%
  group_by(HYBAS_L12) %>%   
  summarise(geometry = st_union(geometry), .groups = "drop") # 

plot(st_geometry(main_rivers[c(16:18),])) # check some "main" rivers

main_rivers <- st_transform(main_rivers, crs = 32630)  # UTM zone 30N

main_rivers_buff <- st_buffer(main_rivers, dist = 200) #200m

plot(st_geometry(main_rivers_buff[c(16:18),]))
plot(st_geometry(main_rivers_buff))

setwd("C:/Users/Propietario/Downloads/ellie")

ts <- readxl::read_xlsx("Global_dataset.xlsx", sheet = 2)
ts_spain <- ts %>% filter(country=="Spain")
ts_spain <- ts_spain[!duplicated(ts_spain$site_id), ]
ts_spain <- ts_spain[,c(1,8,9)] 
ts_spain <- ts_spain %>% drop_na()
ts_spain_sf <- st_as_sf(ts_spain, coords = c("Longitude_X", "Latitude_Y"), crs = 4326)


barrier<- read.csv("atlas.csv")
barrier_spain <- barrier %>% filter(Country=="SPAIN")

# -----
ts_spain_sf <- st_transform(ts_spain_sf, st_crs(main_rivers_buff))
ts_in_river_buffer <- st_join(ts_spain_sf, main_rivers_buff, join = st_intersects)

# Here you see that we have more rows in ts in buffer that the time series in Spain (in fact is the same number but because fo the buffer some time series is in more than one buffer its okay)
nrow(ts_spain) #245
nrow(ts_in_river_buffer) #248
length(unique(ts_in_river_buffer$site_id)) # 245,  see? - all good


barrier_spain_sf <- st_as_sf(barrier_spain, coords = c("Longitude_WGS84", "Latitude_WGS84"), crs = 4326)  # use the appropriate column names for Longitude and Latitude
barrier_spain_sf <- st_transform(barrier_spain_sf, st_crs(main_rivers_buff))
barriers_in_river_buffer <- st_join(barrier_spain_sf, main_rivers_buff, join = st_intersects)


# Lets see if it is working - a random example 
site <- "103000060"
ts_ex = ts_in_river_buffer %>% filter(site_id==site)
plot(st_geometry(ts_in_river_buffer[1, ]))

riv = "2120592530"
rive <- main_rivers_buff %>% filter(HYBAS_L12==riv)
plot(st_geometry(rive))


barr <- barriers_in_river_buffer %>% filter(HYBAS_L12==riv)
plot(st_geometry(barr))


rive_sf <- st_as_sf(rive)
barrier_sf <- st_as_sf(barr)
ts_sf <- st_as_sf(ts_ex)

ggplot() +
  geom_sf(data = rive_sf, color = 'blue', fill = 'lightblue', size = 0.5, alpha = 0.5) +
  geom_sf(data = ts_sf, color = 'red', shape = 21, size = 3, fill = 'red') +
  geom_sf(data = barrier_sf, color = 'purple', shape = 21, size = 1.5, fill = 'purple') +
  labs(subtitle = paste0("River ID:", riv, "   | Time Series ID:", ts_ex)) +
  theme_bw() # Actually seems the Ebro basin 


# Narrowing from the basin ------

main_rivers <- river_spain %>%
  group_by(MAIN_RIV) %>%   
  summarise(geometry = st_union(geometry), .groups = "drop") 
main_rivers <- st_transform(main_rivers, crs = 32630)  # UTM zone 30N
main_rivers_buff <- st_buffer(main_rivers, dist = 200) #200m

ts_spain_sf <- st_transform(ts_spain_sf, st_crs(main_rivers_buff))
ts_in_river_buffer <- st_join(ts_spain_sf, main_rivers_buff, join = st_intersects)

barrier_spain_sf <- st_transform(barrier_spain_sf, st_crs(main_rivers_buff))
barriers_in_river_buffer <- st_join(barrier_spain_sf, main_rivers_buff, join = st_intersects)


site <- "103000060"
ts_ex = ts_in_river_buffer %>% filter(site_id==site)
plot(st_geometry(ts_ex))

riv = "20598415"
rive <- main_rivers_buff %>% filter(MAIN_RIV==riv)
plot(st_geometry(rive))

rive<- river_spain %>% filter((MAIN_RIV==riv))
rive <- st_transform(rive, st_crs(ts_ex))
rive_buff <- st_buffer(rive, dist = 200) #200m


nearest_segment_index <- st_nearest_feature(ts_ex, rive)
nearest_segment <- rive[nearest_segment_index, ]

barr <- barriers_in_river_buffer %>% filter(MAIN_RIV==riv)
plot(st_geometry(barr), add =T)
nearest_segment2 <- st_buffer(nearest_segment, dist = 50)
barriers_in_segment <- barr[st_intersects(barr, nearest_segment2, sparse = FALSE), ]


rive_sf <- st_as_sf(rive_buff)
rive_sf <- st_as_sf(nearest_segment)
barrier_sf <- st_as_sf(barriers_in_segment)
ts_sf <- st_as_sf(ts_ex)

ggplot() +
  geom_sf(data = rive_sf, color = 'blue', fill = 'lightblue', size = 1, alpha = 0.5) +
  geom_sf(data = ts_sf, color = 'red', shape = 21, size = 3, fill = 'red') +
    geom_sf(data = barrier_sf, color = 'purple', shape = 21, size = 1.5, fill = 'purple') +
  labs(subtitle = paste0("River ID:", riv, "   | Time Series ID:", ts_ex)) +
  theme_bw() 






################ TS X GRanD and GDT ############################ <---- I got it to work well for the L12 from HydroBasins as a polygons I made on QGIS but I couldn't get the intersects to work in R the way it does for AMBER - let me know if you have more luck
#Go through the L12s with the TS for dam presence with GDT/GRanD
# analysis for dam primary and secondary use with invasions and community indicies
# regression model for dates of construction with TS

setwd("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer")

#TS in rivers
#ts <- st_read("TS_in_rivers.shp") #### Don't forget to remove the ts that don't have barriers
## Use ts in river buffer

#Rivers with TS
#rivers <- st_read("RiverBuffers_withTS.shp")
#rivers <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/ROI//HydroRIVERS_UK.shp")

### GDT
GDT <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/GDT/GDAT_data_v1/data//GDAT_v1_dams.shp")
#narrow GDT to Europe
EUGDT <- GDT %>% filter(Continent == "Europe")
## Export EUGDT as a shapefile to keep for future work
st_write(EUGDT, "C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/GDT/GDAT_data_v1/data//EU_GDT.shp")

EUGDT <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/GDT/GDAT_data_v1/data//EU_GDT.shp")

### GRanD
GRanD <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/GRanD_Version_1_3//GRanD_dams_v1_3.shp")
#Narrow to European countries
unique(GRanD$COUNTRY)
european_countries <- c(
  "United Kingdom", "Ireland", "France", "Spain", "Portugal", "Netherlands", "Belgium", 
  "Luxembourg", "Germany", "Switzerland", "Italy", "Austria", "Denmark", "Sweden", 
  "Norway", "Finland", "Greece", "Poland", "Czech Republic", "Slovakia", "Hungary", 
  "Romania", "Bulgaria", "Croatia", "Slovenia", "Estonia", "Latvia", "Lithuania", 
  "Malta", "Cyprus"
)
GRanD_europe <- GRanD[GRanD$COUNTRY %in% european_countries, ]
head(GRanD_europe)
#Could also do an intersect the way Ismael did with Spain_box
# or with the shapefile of a polygon of Europe EEA
## Save as shp
st_write(GRanD_europe, "C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/GRanD_Version_1_3//GRanD_Europe.shp")

## Tidying both GDT and GRanD
#Remove any that don't have long/lat/geom
#GDT
names(EUGDT)
anyNA(EUGDT$geomtery)
#GRanD
names(GRanD_europe)
anyNA(GRanD_europe$geometry)
#GRanD <- GRanD[complete.cases(GRanD$LONG_DD), ]

#### Intersecting GRanD, Ts and Rivers ###############
#TS in rivers
ts <- st_read("TS_in_rivers.shp") #### Don't forget to remove the ts that don't have barriers

#Rivers with TS
#rivers <- st_read("RiverBuffers_withTS.shp")
rivers <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/ROI//HydroRIVERS_UK.shp")

main_rivers <- rivers %>%
  group_by(HYBAS_L12) %>%   
  summarise(geometry = st_union(geometry), .groups = "drop")

plot(st_geometry(main_rivers[c(16:18),])) # check some "main" rivers

main_rivers <- st_transform(main_rivers, crs = 32630)  # UTM zone 30N

main_rivers_buff <- st_buffer(main_rivers, dist = 200) #200m

plot(st_geometry(main_rivers_buff[c(16:18),]))
plot(st_geometry(main_rivers_buff))

#ts <- readxl::read_xlsx("Global_dataset.xlsx", sheet = 2)
ts <- ts[!duplicated(ts$site_id), ]
names(ts)
ts <- ts[,c(1,8,9, 12)] 
ts <- ts %>% drop_na()

TS_in_L12 <- st_transform(TS_in_L12, st_crs(main_rivers_buff))
ts_in_river_buffer <- st_join(TS_in_L12, main_rivers_buff, join = st_intersects)

nrow(ts)
nrow(ts_in_river_buffer)
length(unique(ts_in_river_buffer$site_id)) 

# GRanD data #### <---- this is what I couldn't get to work
GRanD_europe <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/GRanD_Version_1_3//GRanD_Europe.shp")
GRanD_europe <- GRanD_europe[,-c(4, 6, 8, 11, 12, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 49, 50, 51, 52, 53, 54, 55, 58)] 
names(GRanD_europe)
GRanD_europe <- st_transform(GRanD_europe, st_crs(main_rivers_buff))
GRanD_in_river_buffer <- st_join(GRanD_europe, main_rivers_buff, join = st_intersects)


#Work done in QGIS 
#intersected L12 with TS and GRanD points <----- this worked ### I can send you these files
QGIS_GRanD_with_TS <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/GRanD_Version_1_3//GRanD_with_TS_L12.shp")
QGIS_TS_with_GRanD <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/GRanD_Version_1_3//TS_with_GRanD.shp")
QGIS_L12_with_TS_and_GRanD <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/GRanD_Version_1_3//L12_with_GRanD_and_TS.shp")

names(QGIS_GRanD_with_TS)
QGIS_GRanD_with_TS <- QGIS_GRanD_with_TS[,-c(2, 3, 4, 6, 9, 10, 11, 12, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 49, 50, 51, 52, 53, 54, 55, 58, 60, 61, 62, 63, 64, 65, 66, 68, 69, 70, 71, 72, 73, 83, 84)] 

unique(QGIS_GRanD_with_TS$HYBAS_ID)
unique(QGIS_TS_with_GRanD$HYBAS_ID)
unique(QGIS_TS_with_GRanD$site_id)
unique(QGIS_L12_with_TS_and_GRanD$HYBAS_ID)


# checking it works with an example
site <- "109000283"
ts_ex <- QGIS_TS_with_GRanD %>% filter(site_id==site)
plot(st_geometry(ts[1, ]))

riv <- "2121095590"
rive <- QGIS_L12_with_TS_and_GRanD %>% filter(HYBAS_ID==riv)
plot(st_geometry(rive))

GRanD <- QGIS_GRanD_with_TS %>% filter(HYBAS_ID==riv)
plot(st_geometry(GRanD))

rive_sf <- st_as_sf(rive)
GRanD_sf <- st_as_sf(GRanD)
ts_sf <- st_as_sf(ts_ex)

ggplot() +
  geom_sf(data = rive_sf, color = 'blue', fill = 'lightblue', size = 0.5, alpha = 0.5) +
  geom_sf(data = ts_sf, color = 'red', shape = 21, size = 3, fill = 'red') +
  geom_sf(data = GRanD_sf, color = 'purple', shape = 21, size = 1.5, fill = 'purple') +
  labs(subtitle = paste0("River ID:", riv, "   | Time Series ID:", ts_ex)) +
  theme_bw() 

### Its works!

## GRanD does only come out with about 15 dams so I am also about to do the same thing with GDT

# Currently going through and doing it with the Hydroriver as well so we can work with the river rather than the whole basin, but for the GRanD and GDT data we don't need to know the distance to the dam or direction or anything just as much and for most their is only one dam per basin so it would be oky to just work with the basin I think




### AMBER x TS ####
######### Basin level (L12) work #########################################################################################################
## Number and types of barriers in the L12 basin 
# total 
# upstream 
# downstream


## Distance to the next closest barrier
## Type of next closest barriers
# relationship between distance and type of next barrier and total, native, and invasive richness


library(sf)
ts_in_river_buffer2 <- st_as_sf(ts_in_river_buffer2)
ts_in_river_buffer2 <- st_transform(ts_in_river_buffer2, st_crs(barriers_in_river_buffer))
distances <- st_distance(ts_in_river_buffer2, barriers_in_river_buffer)
min_distances <- apply(distances, 1, min)
ts_in_river_buffer2$closest_dam_distance <- min_distances

#revert from sf
ts_in_river_buffer2 <- as.data.frame(ts_in_river_buffer2)

library(dplyr)

# Join dfCombine2 with ts_in_river_buffer2 based on site_id
ts_in_river_buffer2 <- ts_in_river_buffer2 %>%
  left_join(select(dfCombine2, site_id, richness), by = "site_id")


#plot
# Create a histogram of the closest dam distances
hist(ts_in_river_buffer2$closest_dam_distance, 
     breaks = "FD",  # Choose the number of breaks using the Freedman-Diaconis rule
     main = "Histogram of Closest Barrier Distances",
     xlab = "Distance to Closest Barrier",
     ylab = "Frequency")

#scatter graph
names(ts_in_river_buffer2)

# create a scatter plot of the closest dam distances against richness
plot(ts_in_river_buffer2$richness, ts_in_river_buffer2$closest_dam_distance,
     main = "Closest Dam Distance vs. TS Richness",
     xlab = "Richness",
     ylab = "Distance to Closest Dam")


library(sf)
library(dplyr)
library(mgcv)  # GAMs

st_crs(ts_in_river_buffer2) ### crs = EPSG:32630 so distance is in meters

# Convert ts_in_river_buffer2 to sf and transform if needed
ts_in_river_buffer2 <- st_as_sf(ts_in_river_buffer2)
ts_in_river_buffer2 <- st_transform(ts_in_river_buffer2, st_crs(barriers_in_river_buffer))

# Calculate distances to barriers and corresponding types
distances <- st_distance(ts_in_river_buffer2, barriers_in_river_buffer)
min_distances <- apply(distances, 1, min)
closest_barrier_index <- apply(distances, 1, which.min)
closest_barrier_type <- barriers_in_river_buffer$type[closest_barrier_index]

# Add the closest barrier distance and type to ts_in_river_buffer2
ts_in_river_buffer2$closest_barrier_distance <- min_distances
ts_in_river_buffer2$closest_barrier_type <- closest_barrier_type

# Join dfCombine2 with ts_in_river_buffer2 based on site_id
ts_in_river_buffer2 <- left_join(ts_in_river_buffer2, select(dfCombine2, site_id, richness), by = "site_id")

# Create a histogram of the closest barrier distances
hist(ts_in_river_buffer2$closest_barrier_distance, 
     breaks = "FD",  # Choose the number of breaks using the Freedman-Diaconis rule
     main = "Histogram of Closest Barrier Distances",
     xlab = "Distance to Closest Barrier",
     ylab = "Frequency")

# Create a scatter plot of the closest barrier distances against richness
names(ts_in_river_buffer2)
ts_in_river_buffer2 <- ts_in_river_buffer2[,-c(13)]
names(ts_in_river_buffer2)
colnames(ts_in_river_buffer2)[15] <- "richness"

plot(ts_in_river_buffer2$richness, ts_in_river_buffer2$closest_barrier_distance,
     main = "Closest Barrier Distance vs. TS Richness",
     xlab = "Richness",
     ylab = "Distance to Closest Barrier")


# Fit GAM model
gam_model <- gam(richness ~ s(closest_barrier_distance), data = ts_in_river_buffer2, method = "REML")
summary(gam_model)
#there is a significant relationship between richness and barrier distance
# but lets find the direction of this relationship ---> increasing distance = increasing richness?
plot(gam_model, select = 1)  # Select the first smooth term for visualization
# Generate predictions along the range of distance values
newdata <- data.frame(closest_barrier_distance = seq(min(ts_in_river_buffer2$closest_barrier_distance), 
                                                     max(ts_in_river_buffer2$closest_barrier_distance), 
                                                     length.out = 100))
# Predict richness using the fitted model
predictions <- predict(gam_model, newdata, type = "response", se.fit = TRUE)
# Plot predicted richness against distance
plot(ts_in_river_buffer2$closest_barrier_distance, ts_in_river_buffer2$richness, 
     main = "Relationship Between Richness and Distance to Closest Barrier",
     xlab = "Distance to Closest Barrier (meters)", ylab = "Richness", ylim = c(0, max(ts_in_river_buffer2$richness)))
# Add smoothed curve
lines(newdata$closest_barrier_distance, predictions$fit, col = "blue", lwd = 2)
# Add confidence intervals
lines(newdata$closest_barrier_distance, predictions$fit + 2 * predictions$se.fit, col = "gray", lty = "dashed")
lines(newdata$closest_barrier_distance, predictions$fit - 2 * predictions$se.fit, col = "gray", lty = "dashed")

# slightly negative relationship????

# go back and make country, temperature, precipitation, and rivers random effects ??!!!!!


## go back through these models to decide whether to use lme4 or glm !!!!


## maybe try it getting rid of the ones that have a greater distance than like 20km !!!!!!!!!!!!!
threshold_distance <- 20000  # 20 km = 20,000 meters
ts_in_river_buffer2$within_20km <- ifelse(ts_in_river_buffer2$closest_barrier_distance <= threshold_distance, TRUE, FALSE)
ts_within_20km <- ts_in_river_buffer2[ts_in_river_buffer2$within_20km, ]

countries_within_20km <- unique(ts_within_20km$country)

length(ts_within_20km$country)
length(ts_within_20km$closest_barrier_distance)
length(ts_within_20km$richness)
any(is.na(ts_within_20km$country))
any(is.na(ts_within_20km$closest_barrier_distance))
any(is.na(ts_within_20km$richness))
names(ts_within_20km)

# Fit linear mixed-effects model
library(nlme)
lme_model <- lme(richness ~ closest_barrier_distance, 
                 random = ~1 | country, 
                 data = ts_within_20km)
summary(lme_model)
#not significant

gam_model <- gam(richness ~ s(closest_barrier_distance), data = ts_within_20km, method = "REML")
summary(gam_model)
#significant relationship

plot(gam_model, select = 1)
newdata <- data.frame(closest_barrier_distance = seq(min(ts_within_20km$closest_barrier_distance), 
                                                     max(ts_within_20km$closest_barrier_distance), 
                                                     length.out = 100))
predictions <- predict(gam_model, newdata, type = "response", se.fit = TRUE)
plot(ts_within_20km$closest_barrier_distance, ts_within_20km$richness, 
     main = "Relationship Between Richness and Distance to Closest Barrier (within 20km)",
     xlab = "Distance to Closest Barrier within 20km (meters)", ylab = "Richness", ylim = c(0, max(ts_within_20km$richness)))
lines(newdata$closest_barrier_distance, predictions$fit, col = "blue", lwd = 2)
lines(newdata$closest_barrier_distance, predictions$fit + 2 * predictions$se.fit, col = "gray", lty = "dashed")
lines(newdata$closest_barrier_distance, predictions$fit - 2 * predictions$se.fit, col = "gray", lty = "dashed")
# curves down then goes back up!!!!



#within 50km 
threshold_distance <- 50000  # 50 km = 50,000 meters
ts_in_river_buffer2$within_50km <- ifelse(ts_in_river_buffer2$closest_barrier_distance <= threshold_distance, TRUE, FALSE)

ts_within_50km <- ts_in_river_buffer2[ts_in_river_buffer2$within_50km, ]
gam_model <- gam(richness ~ s(closest_barrier_distance), data = ts_within_50km, method = "REML")
summary(gam_model)
# still significant

plot(gam_model, select = 1)
newdata <- data.frame(closest_barrier_distance = seq(min(ts_within_50km$closest_barrier_distance), 
                                                     max(ts_within_50km$closest_barrier_distance), 
                                                     length.out = 100))
predictions <- predict(gam_model, newdata, type = "response", se.fit = TRUE)
plot(ts_within_50km$closest_barrier_distance, ts_within_50km$richness, 
     main = "Relationship Between Richness and Distance to Closest Barrier (within 50km)",
     xlab = "Distance to Closest Barrier within 50km (meters)", ylab = "Richness", ylim = c(0, max(ts_within_50km$richness)))
lines(newdata$closest_barrier_distance, predictions$fit, col = "blue", lwd = 2)
lines(newdata$closest_barrier_distance, predictions$fit + 2 * predictions$se.fit, col = "gray", lty = "dashed")
lines(newdata$closest_barrier_distance, predictions$fit - 2 * predictions$se.fit, col = "gray", lty = "dashed")
# v-shaped pattern - peaks around 18 - 20 km


#within 5km
threshold_distance <- 5000  # 5 km = 5,000 meters
ts_in_river_buffer2$within_5km <- ifelse(ts_in_river_buffer2$closest_barrier_distance <= threshold_distance, TRUE, FALSE)

ts_within_5km <- ts_in_river_buffer2[ts_in_river_buffer2$within_5km, ]
gam_model <- gam(richness ~ s(closest_barrier_distance), data = ts_within_5km, method = "REML")
summary(gam_model)
# still significant

plot(gam_model, select = 1)
newdata <- data.frame(closest_barrier_distance = seq(min(ts_within_5km$closest_barrier_distance), 
                                                     max(ts_within_5km$closest_barrier_distance), 
                                                     length.out = 100))
predictions <- predict(gam_model, newdata, type = "response", se.fit = TRUE)
plot(ts_within_5km$closest_barrier_distance, ts_within_5km$richness, 
     main = "Relationship Between Richness and Distance to Closest Barrier (within 5km)",
     xlab = "Distance to Closest Barrier within 5km (meters)", ylab = "Richness", ylim = c(0, max(ts_within_5km$richness)))
lines(newdata$closest_barrier_distance, predictions$fit, col = "blue", lwd = 2)
lines(newdata$closest_barrier_distance, predictions$fit + 2 * predictions$se.fit, col = "gray", lty = "dashed")
lines(newdata$closest_barrier_distance, predictions$fit - 2 * predictions$se.fit, col = "gray", lty = "dashed")
# almost flat - slighltly negative



# within 2km
threshold_distance <- 2000  # 2 km = 2,000 meters
ts_in_river_buffer2$within_2km <- ifelse(ts_in_river_buffer2$closest_barrier_distance <= threshold_distance, TRUE, FALSE)

ts_within_2km <- ts_in_river_buffer2[ts_in_river_buffer2$within_2km, ]
gam_model <- gam(richness ~ s(closest_barrier_distance), data = ts_within_2km, method = "REML")
summary(gam_model)
# still significant

plot(gam_model, select = 1)
newdata <- data.frame(closest_barrier_distance = seq(min(ts_within_2km$closest_barrier_distance), 
                                                     max(ts_within_2km$closest_barrier_distance), 
                                                     length.out = 100))
predictions <- predict(gam_model, newdata, type = "response", se.fit = TRUE)
plot(ts_within_2km$closest_barrier_distance, ts_within_2km$richness, 
     main = "Relationship Between Richness and Distance to Closest Barrier (within 2km)",
     xlab = "Distance to Closest Barrier within 2km (meters)", ylab = "Richness", ylim = c(0, max(ts_within_2km$richness)))
lines(newdata$closest_barrier_distance, predictions$fit, col = "blue", lwd = 2)
lines(newdata$closest_barrier_distance, predictions$fit + 2 * predictions$se.fit, col = "gray", lty = "dashed")
lines(newdata$closest_barrier_distance, predictions$fit - 2 * predictions$se.fit, col = "gray", lty = "dashed")
# really similar to 5


#within 500m
threshold_distance <- 500  #500 meters
ts_in_river_buffer2$within_500m <- ifelse(ts_in_river_buffer2$closest_barrier_distance <= threshold_distance, TRUE, FALSE)

ts_within_500m <- ts_in_river_buffer2[ts_in_river_buffer2$within_500m, ]
gam_model <- gam(richness ~ s(closest_barrier_distance), data = ts_within_500m, method = "REML")
summary(gam_model)
# still significant

plot(gam_model, select = 1)
newdata <- data.frame(closest_barrier_distance = seq(min(ts_within_500m$closest_barrier_distance), 
                                                     max(ts_within_500m$closest_barrier_distance), 
                                                     length.out = 100))
predictions <- predict(gam_model, newdata, type = "response", se.fit = TRUE)
plot(ts_within_500m$closest_barrier_distance, ts_within_500m$richness, 
     main = "Relationship Between Richness and Distance to Closest Barrier (within 500m)",
     xlab = "Distance to Closest Barrier within 500m (meters)", ylab = "Richness", ylim = c(0, max(ts_within_500m$richness)))
lines(newdata$closest_barrier_distance, predictions$fit, col = "blue", lwd = 2)
lines(newdata$closest_barrier_distance, predictions$fit + 2 * predictions$se.fit, col = "gray", lty = "dashed")
lines(newdata$closest_barrier_distance, predictions$fit - 2 * predictions$se.fit, col = "gray", lty = "dashed")
# almost flat - slighltly negative


## Note 20km buffer is the best



###### with distance and type ############
install.packages("gamlss")
library(gamlss)
# Fit GAMLSS model with both continuous and categorical predictors
ts_in_river_buffer2 <- na.omit(ts_in_river_buffer2)
gamlss_model <- gamlss(richness ~ pb(closest_barrier_distance) + factor(closest_barrier_type), data = ts_in_river_buffer2)
summary(gamlss_model)

### significant relationship between distance and richness
### most significant relationship is with sluice?
### also significant relationships with dams and weirs
#                                     Estimate Std. Error t value Pr(>|t|)    
#(Intercept)                         2.762e+01  1.141e+00  24.204  < 2e-16 ***
#pb(closest_barrier_distance)       -2.940e-05  4.927e-06  -5.967 2.63e-09 ***
#factor(closest_barrier_type)dam     3.420e+00  1.328e+00   2.575  0.01007 *  
#factor(closest_barrier_type)other  -7.179e-01  1.264e+00  -0.568  0.57016    
#factor(closest_barrier_type)ramp    2.022e+00  1.451e+00   1.393  0.16371    
#factor(closest_barrier_type)sluice -4.335e+00  1.412e+00  -3.071  0.00215 ** 
#factor(closest_barrier_type)weir    2.702e+00  1.178e+00   2.294  0.02185 *  


# within 20km 
threshold_distance <- 20000  # 20 km = 20,000 meters
ts_in_river_buffer2$within_20km <- ifelse(ts_in_river_buffer2$closest_barrier_distance <= threshold_distance, TRUE, FALSE)
ts_within_20km <- ts_in_river_buffer2[ts_in_river_buffer2$within_20km, ]

#try with country as a random effect
length(ts_within_20km$closest_barrier_distance)
length(ts_within_20km$closest_barrier_type)
length(ts_within_20km$richness)

gam_model <- gam(richness ~ s(closest_barrier_distance) + closest_barrier_type, data = ts_within_20km, method = "REML")
summary(gam_model)
#significant relationship with dam and sluice, weir and ramp are low
plot(gam_model, select = 1)
newdata <- data.frame(closest_barrier_distance = seq(min(ts_within_20km$closest_barrier_distance), 
                                                     max(ts_within_20km$closest_barrier_distance), 
                                                     length.out = 100))
predictions <- predict(gam_model, newdata, type = "response", se.fit = TRUE)
plot(ts_within_20km$closest_barrier_distance, ts_within_20km$richness, 
     main = "Relationship Between Richness and Distance to Closest Barrier (within 20km)",
     xlab = "Distance to Closest Barrier within 20km (meters)", ylab = "Richness", ylim = c(0, max(ts_within_20km$richness)))
lines(newdata$closest_barrier_distance, predictions$fit, col = "blue", lwd = 2)
lines(newdata$closest_barrier_distance, predictions$fit + 2 * predictions$se.fit, col = "gray", lty = "dashed")
lines(newdata$closest_barrier_distance, predictions$fit - 2 * predictions$se.fit, col = "gray", lty = "dashed")


#lme model
lme_model <- lme(richness ~ closest_barrier_distance + closest_barrier_type, 
                 random = ~1 | country, 
                 data = ts_within_20km)
summary(lme_model)
# none are significant but dam and weir have the lowest p value

# glmm???



#### Next do all this with native vs invasive richness ##############
# Check unique values in the "alien" column
# Model the richness of invasive and native species
names(NoNN)
names(ts_within_20km)

NoNN$site_id <- as.character(NoNN$site_id)
NoNN$year <- as.character(NoNN$year)

ts_within_20km <- ts_within_20km %>%
  left_join(NoNN, by = c("site_id", "year"))

names(ts_within_20km)
colnames(ts_within_20km)[7] <- "Alien"
colnames(ts_within_20km)[15] <- "richness" #this is total richness -- double check!
colnames(ts_within_20km)[23] <- "NoNN_Alien"
colnames(ts_within_20km)[24] <- "NoNN_Richness"

#filter the richness just for those with invaders
ts_within_20km_IAS <- ts_within_20km[ts_within_20km$NoNN_Alien == "Y", ]

# GAM for invaders
gam_model <- gam(NoNN_Richness ~ s(closest_barrier_distance) + closest_barrier_type, 
                 data = ts_within_20km_IAS, 
                 method = "REML")
summary(gam_model)


gam_model <- gam(NoNN_Richness ~ s(closest_barrier_distance), 
                 data = ts_within_20km_IAS, 
                 method = "REML")
summary(gam_model)


gam_model <- gam(NoNN_Richness ~ closest_barrier_type, 
                 data = ts_within_20km_IAS, 
                 method = "REML")
summary(gam_model)

# there is a significant relationship with dams 
# but very significant relationship with sluices????


### for native richness
ts_within_20km_Native <- ts_within_20km[ts_within_20km$NoNN_Alien == "N", ]

gam_model <- gam(NoNN_Richness ~ s(closest_barrier_distance) + closest_barrier_type, 
                 data = ts_within_20km_Native, 
                 method = "REML")
summary(gam_model)



gam_model <- gam(NoNN_Richness ~ s(closest_barrier_distance), 
                 data = ts_within_20km_Native, 
                 method = "REML")
summary(gam_model)



gam_model <- gam(NoNN_Richness ~ closest_barrier_type, 
                 data = ts_within_20km_Native, 
                 method = "REML")
summary(gam_model)

# same sort of results as IAS but no significant relationship with dams!!!! - then we move on to GRanD and GDT


# all the above work was done according to HYBAS_L12 -- this was all the work we have been doing for the last few months -- so make sure to do this
# it gives justification to use the basin rather than just a proxy radius !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!





########### AMBER X TS L4 ############################################################################ <- 
###### Whole catchment (L4) level work #######

RiverBuffers_withTS <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer//RiverBuffers_withTS.shp")
intersecting_barriers <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer/Intersecting barrier chunks/CSVs//intersecting_barriers.shp")
river_buffers <- st_read("C:/Users/User/OneDrive - Queen's University Belfast/PhD/AMBER Data/Output_RiverBuffer//WholeRiv_Buffers.shp")

head(RiverBuffers_withTS)

# we will use strahler order as a proxy for flow direction <--- still trying to think of another way
# also workign to use elevation for this


# currently I am working to get the number and types of barriers upstream and downstream - from whole way between headwaters and mouth of rivers <- this will be ready soon








####################################################################################################
########### Modelling the GRanD/GDT x TS relationship #############
######### Basin level (L12) work ##########
### Distance to the next closest dam
# relationship between distance to barrier and total, native, and invasive richness <- should this be a regression not model
# relationship between if the TS is upstream or downstream of the dam
### Maybe there are more than one TS in each basin
# identify the TS which is upstream and the one which is downstream
# how do these communities differ?? e.g., more invaders downstream??


### Relationship with the TS and height of the dam
# is there a difference in the upstream and downstream TS depending on height

#### is height or diftance to the barrier having a greater impact on the nearby TS


### find out if there is more than one dam in the L12 basin <-- this might not be done as I think there are only maybe 30 dams 
# is there a relationship between richness and the number of dams --- e.g., with increasing number of dams doens richness of natives decrease?
# is the upstream or downstream dam having a greater impact


### Is there a relationship between the main and secondary uses of the dams and the total, native, and invasive richness
# does the effect of dam use change if the TS is upstream vs downstream of the dam 



### Regression of the year of construction of the dam against the TS
# at L12 level
# at whole catchment level 
## if there is a change in this we can also look at the distance to which the effects of dam construction are most significant



## distance from each TS to the closest dam
library(sf)
# st_distance
QGIS_TS_with_GRanD <- st_transform(QGIS_TS_with_GRanD, st_crs(QGIS_GRanD_with_TS))
distances <- st_distance(QGIS_TS_with_GRanD, QGIS_GRanD_with_TS)
min_distances <- apply(distances, 1, min)
QGIS_TS_with_GRanD$closest_dam_distance <- min_distances

names(QGIS_TS_with_GRanD)
QGIS_TS_with_GRanD <- QGIS_TS_with_GRanD[,-c(6, 27:37, 96, 98, 99, 102:121)] 


GRanD_Richness <- QGIS_TS_with_GRanD %>% 
  group_by(site_id) %>% #could also add year here but have to add years to dams as well
  summarise(richness = n())

QGIS_TS_with_GRanD <- st_join(QGIS_TS_with_GRanD, GRanD_Richness, join = st_intersects)

names(QGIS_TS_with_GRanD)

# Create a histogram of the closest dam distances
hist(QGIS_TS_with_GRanD$closest_dam_distance, 
     breaks = "FD",  # Choose the number of breaks using the Freedman-Diaconis rule
     main = "Histogram of Closest Dam Distances",
     xlab = "Distance to Closest Dam",
     ylab = "Frequency")

# create a scatter plot of the closest dam distances against one of the site characteristics
plot(QGIS_TS_with_GRanD$richness, QGIS_TS_with_GRanD$closest_dam_distance,
     main = "Closest Dam Distance vs. TS Richness",
     xlab = "Richness",
     ylab = "Distance to Closest Dam")

plot(dfCombine2$richness, ts$closest_dam_distance,
     main = "Closest Dam Distance vs. TS Richness",
     xlab = "Richness",
     ylab = "Distance to Closest Dam")
#try to add a trend line --- seems to be a general increase


######## Models
#modelling ts and distance to dam

# only use the ts that are in rivers with dams
library(mgcv)
gam_model <- gam(dfCombine2$richness ~ s(ts$closest_dam_distance), family = poisson)
summary(gam_model)

plot(dfCombine2$richness, ts$closest_dam_distance,
     main = "Closest Dam Distance vs. TS Richness",
     xlab = "Richness",
     ylab = "Distance to Closest Dam")
lines(dfCombine2$richness, predict(gam_model), col = "red")


plot(dfCombine2$richness, ts$closest_dam_distance,
     main = "Closest Dam Distance vs. TS Richness",
     xlab = "Richness",
     ylab = "Distance to Closest Dam")
lines(dfCombine2$richness, predict(gam_model), col = "red")


#Model the effects of dam presence and absences??

# Model the interaction between TS and dam use!!
gam_richness_invasive <- gam(richness_invasive ~ s("main use") + s("secondary use"), data = your_data, family = poisson)
summary(gam_richness_invasive)
plot(gam_richness_invasive)

# Try to also bring in GDT - check online if I have the most up to date files



# Model dam height and size


# Ellie modelling - Ismael


pred <- read_xlsx("predictors.xlsx")
pred <- pred[!duplicated(pred[,c("site_id","year")]), ]
names(pred)
head(pred)

type_barrier= read_xlsx("number_type_barriers.xlsx")
type_barrier <- type_barrier %>%
  group_by(site_id) %>%
  summarise(
    culvert = sum(culvert, na.rm = TRUE),
    dam = sum(dam, na.rm = TRUE),
    ford = sum(ford, na.rm = TRUE),
    other = sum(other, na.rm = TRUE),
    ramp = sum(ramp, na.rm = TRUE),
    sluice = sum(sluice, na.rm = TRUE),
    weir = sum(weir, na.rm = TRUE)  )

type_barrier <- type_barrier %>%
  mutate(total_barriers = rowSums(dplyr::select(., culvert:weir)))


#close_barrier= read_xlsx("TS_with_closest_barriers.xlsx")
#close_barrier = close_barrier[,c(1,2,14,15)]


data <- left_join(pred, type_barrier, by = c("site_id")) 
data2 <- data %>% drop_na() 

unique(data2$site_id) # 60 sites?


# I want to include here the abundance per year (yes sorry - i have been talking with chat gtpt) and country, coordinates
setwd("C:/Users/Propietario/Desktop/Escritorio/full databse/DATA")
df <- read_xlsx("Global_dataset.xlsx", sheet = "Sheet1")
df1 = df %>% group_by(site_id, year) %>% mutate(Abundance = sum(abundance),
                                                Richness = n_distinct(taxon))

data3 <- left_join(data2, df1[,c(1,2,12,5,8,9,13)], by = c("site_id", "year")) 
data3 <- data3[!duplicated(data3[,c("site_id","year")]),]

unique(data3$site_id)

## okay I am retarded I see the values are in the next database 

ts <- st_read("dfTS_L12.shp")
names(ts)

ts$site_id <- as.character(ts$site_id)
ts$year <- as.character(ts$year)
data3$site_id <- as.character(data3$site_id)
data3$year <- as.character(data3$year)


# lets combine the res. variable
data4 <- left_join(data3, ts[,c(1:7,9,10,15,17)], by = c("site_id","year")) 
data4 <-data4 %>% filter(year > 1994) # threshold that me mentioned 1995 
data4 <- data4[!duplicated(data4[,c("site_id","year")]),]

# Note that we will try to make resp. variable per year, e.g., total abundance, richness, etc, 
# here i calculated total abundance and richness as example

length(unique(data4$site_id)) # only 59 ts ?

min(data4$year) # 1995 

# Model  -----
# lets try first with glm 

hist(data4$Richness)  # Better that expected, however here we have to consider few things:
# count data (richness)
# left skewed
# 2 main options negative binomial and poisson

mean(data4$Richness)
sd(data4$Richness)

data4$year <- as.numeric(data4$year)
data4$site_id <- as.factor(data4$site_id)
names(data4)

install.packages("glmmTMB")
library(glmmTMB)

str(data4)

predictors <- c("distance_to_outlet", "distance_to_weir", "culvert", "dam", 
                "ford", "other", "ramp", "sluice", "weir", "total_barriers")

formula <- as.formula(paste("Richness ~", paste(predictors, collapse = " + ")))

nrow(data4)

model1 <- glmmTMB(Richness ~ distance_to_outlet+ distance_to_weir +culvert+ dam+ year+
                  ford+other+ ramp+ sluice+ weir+  (1|country/site_id),
                  data = data4, family = nbinom2)

summary(model1)

# plot results

sjPlot::plot_model(model1, type = "re", show.values = TRUE, value.offset = 0.3) # random effect
sjPlot::plot_model(model1, type = "est", show.values = TRUE, value.offset = 0.3)  # fixed effect

# Predicted vs. observed plot
data4$predicted <- predict(model1, type = "response")
ggplot(data4, aes(x = predicted, y = Richness)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red", size= 1.5) +
  labs(x = "Pred", y = "Obs", title = "Mbappe") +
  theme_bw()


# abundance model -- 

hist(data4$Abundance) # much clear the skewed, we might need a transformation
data4$Abundance <- round(data4$Abundance)

model2 <- glmmTMB(Abundance ~ distance_to_outlet+ distance_to_weir +culvert+ dam+ year+
                    ford+other+ ramp+ sluice+ weir+  (1|country/site_id),
                  data = data4, family = nbinom2)

summary(model2)

write_xlsx(data4, "Ellie_data.xlsx")


#### Isma fix 10/06/2024
getwd()
setwd("C:/Users/Propietario/Downloads/ellie-1/data")
data <- readxl::read_xlsx("Ellie_completedata.xlsx")

names(data)
str(data)

data <- data[!duplicated(data[c("site_id","year")]), ]
install.packages("glmmTMB")
library(glmmTMB)
library(magrittr)

predictors <- c("distance_to_outlet", "distance_to_weir", "culvert", "dam", "ford", "other", "ramp", "sluice", "weir", "total_barriers")
formula <- as.formula(paste("Richness ~", paste(predictors, collapse = " + ")))

nrow(data)
summary(data)
data <- data[,c("Richness", "year", "Country", "site_id", predictors)]
data<- data %>%  tidyr::drop_na()
data$year <- as.numeric(data$year)

anyNA(data)
mean(data$distance_to_outlet)

model1 <- glmmTMB(Richness ~ distance_to_outlet+ distance_to_weir +culvert+ dam+ 
ford+other+ ramp+ sluice+ weir+  (1|site_id),
data = data, family = nbinom2)

summary(model1)

# Note for Ellie: I tried several model I am also surprise of this converge problem but seems we avoid it by removing collinearity (redundant varaibles) - but we lost some types of barries (statistically correct but not sure ecological) 
# Also I noted that we have super few data now
nrow(data) # 60 rows = max 6 predictors
# You can see how some most of the site id contain only one row how is that posible?
table(data$site_id)

library(caret)
vif_values <- car::vif(lm(Richness ~ ., data = data[, c("Richness", "distance_to_outlet", "distance_to_weir", "culvert", "ford", "other", "ramp", "sluice", "weir")]))

model2 <- glmmTMB(Richness ~ distance_to_outlet+ distance_to_weir + dam+
ford+ sluice+ weir+  (1|site_id),
data = data, family = nbinom2)

summary(model2)

#                     Estimate Std. Error z value Pr(>|z|)
#(Intercept)         3.549e+00  6.646e-02   53.39   <2e-16 ***
#distance_to_outlet -3.891e-07  2.291e-07   -1.70   0.0894 .
#distance_to_weir   -2.335e-04  2.521e-04   -0.93   0.3543
#dam                 1.222e-04  1.884e-04    0.65   0.5165    
#ford               -3.442e-04  5.959e-04   -0.58   0.5636
#sluice              8.563e-05  6.894e-04    0.12   0.9012
#weir                7.771e-06  3.406e-05    0.23   0.8195


model3 <- glmmTMB(Richness ~ scale(distance_to_outlet) + scale(distance_to_weir) + dam, 
                  data = data, family = nbinom2)

summary(model3)


# read: https://www.rdocumentation.org/packages/MASS/versions/7.3-60.0.1/topics/glmmPQL
model_extra <- glmmPQL(Richness ~ distance_to_outlet+ distance_to_weir +culvert+ dam+ 
ford+other+ ramp+ sluice+ weir, random = ~ 1 | site_id, family = negative.binomial(theta = 1), data = data)

summary(model_extra)

vif_values <- car::vif(lm(Richness ~ ., data = data[, c("Richness", "distance_to_outlet", "distance_to_weir", "culvert","dam", "ford", "other", "ramp", "sluice", "weir")]))
vif_values <- car::vif(lm(Richness ~ ., data = data[, c("Richness", "distance_to_outlet", "distance_to_weir","dam", "ford", "other", "ramp", "sluice", "weir")]))
vif_values <- car::vif(lm(Richness ~ ., data = data[, c("Richness", "distance_to_outlet", "distance_to_weir","dam", "ford", "ramp", "sluice", "weir")]))

model_extra2 <- glmmPQL(Richness ~ distance_to_outlet+ distance_to_weir + dam+ 
ford+ ramp+ sluice+ weir, random = ~ 1 | site_id, family = negative.binomial(theta = 1), data = data)

summary(model_extra2)


